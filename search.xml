<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kubernetes概述与架构]]></title>
    <url>%2F2018%2F06%2F24%2Ftech%2Fk8s%2FKubernetes%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Kubernetes是一个用于管理容器化应用和服务的轻便和可扩展的开源平台。通过Kubernetes能够进行应用的自动化部署和扩缩容。在Kubernetes中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。 主要特性1.自动化装箱：对资源的要求和约束自动部署容器，同时为了提高利用率和节省更多资源，将关键和最佳工作量结合在一起。 2.自愈能力：当容器失败时，对容器进行重启；当部署的Node节点有问题时，对容器进行重新部署和重新调度；当容器未通过监控检查时，会关闭容器；只有容器正常运行，才会对外提供服务。 3.水平扩展：通过简单命令、用户界面或者基于CPU的适用情况对应用容器进行扩展。 4.服务发现和负载均衡：基于Kubernetes进行服务发现和负载均衡，开发者不需要适用额外的服务发现机制。 5.自动发布和回滚：Kubernetes能够程序化的发布应用和相关配置，如果发布有问题，能够会贵发生的变更。 6.保密和配置管理： 在不需要重新构建镜像的情况下，可以部署和更新保密和应用配置。 7.存储编排：自动挂接本地、公有云、网络存储系统。 架构图Kubernetes属于主从分布架构，主要由Master Node、Worker Node、Kubectl和其他附加项构成。 Master NodeMaster Node是控制节点，对整个集群进行调度管理。它由API Server、Scheduler、Cluster State Store和Controller-Manager组成. API ServerAPI Server是所有REST命令的入口，用于REST的操作，确保它们生效，执行相关业务逻辑，以及更新etcd。另外，API Server作为集群网关。默认情况下，客户端通过API Server对集群进行访问。 SchedulerScheduler组件为容器自动选择运行的主机。依据请求资源的可用性，服务请求的质量等约束条件，监控未绑定的pod, 并将其绑定至特定的node节点。 Scheduler可以依据的调度策略主要有预选策略和优选策略。 Cluster State StoreKubernetes默认使用etcd作为集群整体存储。etcd是一个简单的、分布式的、一致的key-value存储，主要被用来共享配置和服务发现。etcd提供了一系列CRUD操作API，以及作为注册的接口用于监控置顶的Node。集群所有的状态都存储在etcd实例中，并具有监控能力，当etcd中的信息发生变化时，就能够快速的通知集群相关的组件。 Controller-Manager用于执行大部分的集群层次功能，它即执行例如命名空间创建、生命周期管理、事件垃圾收集、已终止垃圾收集、联级删除垃圾收集、node垃圾收集等生命周期功能，也执行例如pod的弹性扩容等API业务逻辑。控制管理提供自愈能力、扩容、应用生命周期管理、服务发现、路由、服务绑定等。 Worker NodeWorker Node作为真正的工作节点，运行业务应用的容器；其包含kubelet、kube proxy和Container Runtime kubeletKubelet是Pod和Node API的主要实现者，并负责驱动容器执行层，负责管理Pod、容器、镜像和数据卷，实现集群对节点的管理，并将容器的运行状态汇报给Kubernetes API Server。在Kubernetes中，Pod作为基本的执行单元，它可以拥有多个容器和存储数据卷，能够方便在每一个容器中打包一个单一的应用，从而解耦了应用构建时和部署时的所关心的事项，已经能够方便在物理机/虚拟机之间进行迁移。API准入控制可以拒绝Pod，或者为Pod添加外的调度约束，但是Kubelet才是Pod是否能够运行在特定Node上的最终裁决者。 Container Runtime每一个Node都会运行一个Container Runtime, 其负责下载镜像和运行容器。 Kubernetes本身不提供容器运行环境，但提供了接口，可以插入所选择的容器运行时环境。Kubelet使用Unix socket之上的gRPC框架与容器运行时进行通信， Kubelet作为客户端，CRI shim作为服务器。 protocal buffers API提供ImageService和RuntimeService两个gRPC服务。ImageService提供拉去、查看和移除镜像的RPC。RuntimeService则提供管理Pods和容器生命周期管理的RPC，以及与容器进行交互(exec/attach/port-forward)。 Kube proxy基于一种公共访问策略（例如：负载均衡），服务提供了一种访问一群pod的途径。此方式通过创建一个虚拟的IP来实现，客户端能够访问此IP，并能够将服务透明的代理至Pod。每一个Node都会运行一个kube-proxy，kube proxy通过iptables规则引导访问至服务IP，并将重定向至正确的后端应用，通过这种方式kube-proxy提供了一个高可用的负载均衡解决方案。服务发现主要通过DNS实现。 在Kubernetes中，kube proxy负责为Pod创建代理服务；引到访问至服务；并实现服务到Pod的路由和转发，以及通过应用的负载均衡。 Kubectlkubectl是Kubernetes集群的命令行接口。运行kubectl命令的语法如下所示： 1$ kubectl [command] [TYPE] [NAME] [flags]]]></content>
      <categories>
        <category>温故知新</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强化学习要点]]></title>
    <url>%2F2018%2F06%2F23%2Ftech%2Fai%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[广袤的塞伦盖蒂大草原上，一只角马的幼崽刚刚降生。它挣扎着，努力的站起来，一开始摇摇晃晃，不断的跌倒又站起，然后慢慢的站稳了，并开始向前走，再接着开始奔跑，来到角马母亲身旁，然后享受甘甜的乳汁。 定义强化学习是机器学习的一个重要分支，主要是用于解决decision making问题，可以自主进行（连续）决策。它主要包含Agent, Environment, Action, Reward四个元素，其目标是获取最大的Reward。 与（非）监督学习的区别我们通常说机器学习包含监督学习和非监督学习，但在定义中强化学习也是机器学习的一个重要分支，那么它与传统的监督学习与非监督学习的区别是什么？ 与监督学习的对比1.监督学习训练集结果有标签；强化学习没有，需要尝试一些行为得出一个结果然后根据结果的反馈调整之前的行为。 2.监督学习算法能够从结果中马上得到反馈；强化学习的结果反馈有延时，有时要经过好几步后才能知晓前面的行为是否有问题。 3.监督学习的输入是独立分布的；强化学习输入总在变化，当算法做出一个行为时，它能够影响下一个输入，输入是相关联的。 4.监督学习一般只会尝试过去经验中最有效的行为（exploitation）；强化学习可以在尝试不同事务（exploration）和尝试过去经验中最有效行为（exploitation）两者中找到平衡点，从而得到最大回报。 5.监督学习会学习得到一个输入与输出的映射关系；强化学习给出的是reward function，用来判断行为的好坏。 与非监督学习的对比 在用户推荐系统中，非监督学习会找出与用户先前行为类似的行为；强化学习则通过向用户推荐一些，等待用户反馈后修正对用户的推荐。 非监督学习得到的结果是输入与输出的模式；强化学习得到是映射。 算法分类强化学习的算法可以以reward,action,policy几个主要元素角度进行区分. Reward based是算法关注找到最优奖励总和； Action based是算法关注找到每一步的最优行动； Policy based是算法关注找到最优的策略； 在上述的基础上，还有进行更加细分区分： 算法 Model-free Model-based Policy-based Reward-based MC-update TD-update On-policy Off-policy QLearning True True True True True Sarsa True True True True True Policy Gradients True True True True Actor-critic True True Policy Gradients V2 True MC learning True Sarsa lambda True Deep Q Network True Model-free: 不尝试去理解环境，环境给什么就是什么，一步一步等待真是世界的反馈，再根据反馈采取下一步的行动；Model-based: 先理解真实世界是怎样的，并建立一个模型来模拟现实世界的反馈，然后通过想想来预判接下来将要发生的所有情况，选择这些想象中最好的，并依据这种情况采取下一步策略，相对于Model-free算法多处一个虚拟环境，更有想象力；Policy-based: 通过感官分析所处的环境，直接输出下一步要采取的各种动作的概率，然后根据概率采取行动；Reward-based: 输出的是所有动作的价值，根据最高价值来选动作，这类方法不能选区联系的动作；MC-update: Monte-carlo update是指游戏开始后，要等待游戏结束后，然后再总结这一回合中的所有转折点，再更新新的行为准则；TD-update: Temporal-difference update是指在游戏进行中每一步都在更新，不用等待游戏结束，这样就能边玩边学;On-policy： 必须本人在场，且一定是本人边玩边学习；Off-policy: 可以选择自己玩也可以看着别人玩，通过看别人玩来学习别人的行为准则； 引用1.一文了解强化学习]]></content>
      <categories>
        <category>温故知新</category>
        <category>AI</category>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>强化网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的分库与分表]]></title>
    <url>%2F2018%2F06%2F13%2Ftech%2Farch%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%86%E5%BA%93%E4%B8%8E%E5%88%86%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[在系统设计与架构时，绝大多数是绕不开数据库的。数据库的选型、部署方案、数据结构的切分、优化等等都是一系列需要思考的。文本针对数据库优化中的分库分表做一些阐述。 写在前面什么是最好的数据库分库分表方案？ 不需要分库分表的方案是最好的。但随着业务的发展，系统数据量和访问量的增加，有时候要进入到不得不分库分表的阶段。总结起来，分库分表的原因可以归结为： 数据的读取量急剧增加，以至于内存不能满足其需求，说白了就是内存容量不够； 数据的读取变化频幅很快，以至于查询的数据不是来自于内存还是来自硬盘； 数据的写操作超过了磁盘负载，以至于数据副本的同步更新远落后与写入操作； 具体到数据库层面，表现为： 数据库读写请求量太大； 单库数据过大； 单表数据过大； 因此，所有的分库分表方案都是基于解决上述三个问题。 面临的问题俗话说“有得必有失”，针对数据库的分库分表操作也一样。进行分库分表后可能付出的代价可能有以下几种： 原先的SQL语句不再是申明式的 数据库通过SQL语句获知用户的意图，然后适用优化器进行优化，并将优化后的SQL转换成获取程序。分库分表后，这种优势可能被打破。 可能会导致大量的网络延时 在分布式环境下，查询语句必须要通过KV映射，访问多个网络节点，或者将WHERE条件放在他们将被执行的节点上, 但是即使在最好的情况下，涉及到多个网络访问都会更加复杂。 将会失去一些SQL的强大功能 例如外键约束等 异步查询的数据不能顺序返回 当相同类型的数据存放在多个节点上（例如用户数据存放在A,B,C节点上），水平查询需要访问所有节点，数据访问时间直接因以节点数线性增长。除非多个节点是以并行方式访问，然后再以MapReduce的方式聚合。前提是需要提供异步通信的API，但这并不存在于MySQL提供的功能中, 可选的方案是在子进程中增加很多的forking和连接。 切分方法切分方法多种多样，本文将从架构层级切分和物理层级切分进行简要描述。 架构层级切分 切分方法 优点 缺点 业务功能切分 相关表都在本地，可以享受声明式的SQL语句好处， 网络延时少 可能出现单个表单数据过大的情况 业务应用层切分 可选的方案多，灵活 处理细节多，技术细节复杂。 物理切分 方法 垂直切分 水平切分 分表 大表切成小表， 拆分字段， 建扩展表 对数据量巨大的单表按照某种规则(RANGE, HASH取模等)，切分成多张表 分库 针对不同业务进行拆分 将单张表切分到多个服务器中]]></content>
      <categories>
        <category>温故知新</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习通用优化方法]]></title>
    <url>%2F2018%2F06%2F12%2Ftech%2Fai%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%80%9A%E7%94%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[深度学习的最终目标是找到最优或者近似最优的模型。当有一个模型被训练出来后，怎么去改进？是否有一个通用的方法？ 土豪法你认识或者自己就是研究领域的专家，拥有强大GPU计算集群，几乎没有限制的训练数据，先进模型的理论、架构与设计。最后有足够的时间和耐心，或者有助手帮助调参，迭代模型。 通用法通用法一般通过迁移开源的先进的模型、总结一些常用超参的调优手法进行改善模型的拟合时间和准确性。具体可以分为以下几个步骤： 模型迁移前的准备：了解最新理论成果与理想的或者目前实践上最优的模型，研究其预训练体系结构。了解迁移学习的好处，思考要解决问题的领域与现有模型的共性问题。 模型的裁剪模型的前几层，主要是提取通用的和可以解释的特征。在迁移时，不需要修改和调整。输出层则需要进行修改，主要是使用适合应用领域的激活函数和输出维度替换模型的默认输出。 训练优化1.使用较小的学习率，这是因为预训练的权重通常优于随机初始化的权重，因此修改要更为精细。2.使用Dropout层。和传统的回归模型的Ridge和LASSO正则化一样，Dropout不会适用于所有的模型。他的适用取决于具体问题，需要进行测。3.通过限制有些层的权重的最大范数（绝对值）来提高模型的泛化能力。]]></content>
      <categories>
        <category>温故知新</category>
        <category>AI</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[占卜:小米招股前景]]></title>
    <url>%2F2018%2F06%2F11%2Fdivine%2F%E5%B0%8F%E7%B1%B3%E6%8B%9B%E8%82%A1%E5%89%8D%E6%99%AF%2F</url>
    <content type="text"><![CDATA[“巨树散枝开花飘全球，根扎市场吸金流，到底是花香为大众，还是花是画金是金？” 上市圈钱都不是问题，问题是圈钱的目的是做产品还是圈钱。看好其后10年的发展。]]></content>
      <categories>
        <category>占卜记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题高级设置]]></title>
    <url>%2F2018%2F06%2F11%2Fguider%2Fhexo%2FHexo%E4%B8%BB%E9%A2%98%E9%AB%98%E7%BA%A7%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[这是Hexo系列的第三篇，主要记录一些NexT主题的一些高级特性设置，比如置顶、开启搜索，进行SEO设置等。 文章置顶功能设置文字的置顶级别top数，达到对文章的置顶设置。该功能就是修改node_modules/hexo-generator-index/lib/generator.js文件，添加根据top数值大小排序代码，从而实现该功能。 1234567891011121314151617181920212223242526module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 如果需要对文章置顶，需要在文章的meta中添加top关键字，并设置相应的数值1234567---title: Hexo主题高级设置date: 2018-06-10 17:44:33tags: [Hexo, 教程]categories: [教程系列, 工具类]top: 100--- 添加文章结束标记创建模板创建一个模板文件themes/next/layout/_macro/post-end-tag.swig 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------本文结束------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 引用模板将创建的模板添加到themes/next/layout/_macro/post.swig中 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'post-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 添加配置最后在主题配置文件中添加12post-end-tag: enabled: true 创建404页面 404页面只有发布到站点并使用域名时才会显示，本地调试或者GitHub pages域名都不能显示404页面 使用命令新建404页面， 1$ hexo new page 404 然后编辑source/404/index.md中的内容，需要注意的是需要在meta中标明permalink 123456---title: 未找到该页面date: 2018-06-11 23:07:24comments: falsepermalink: /404--- 开启本地搜索下载hexo-generator-searchdb依赖包，然后enabled搜索配置 123456789local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false 开启社区分享功能将]]></content>
      <categories>
        <category>教程系列</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题NexT配置与优化]]></title>
    <url>%2F2018%2F06%2F10%2Fguider%2Fhexo%2FHexo%E4%B8%BB%E9%A2%98NexT%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[上一篇《Hexo安装与配置》主要记录Hexo博客站点的设置过程，这一篇主要从基本设置、功能扩展和样式优化三个方面讲述NexT主题的配置。本文参考了《Hexo-Next-主题优化》系列博文，在此对作者表示感谢。NexT目前的版本的已经升级到v6.3.0，本文将以此版本为例。 前期准备下载NexT主题v6.3.0解压到themes文件夹中并重命名为next，修改站点配置文件_config.yml中的主题设置。 在没有特别说明的情况下，配置文件默认是themes/next/_config.yml主题配置文件。 基本设置主题风格NexT主题支持Muse、Mist、Pisces和Gemini四种风格，可以根据个人喜好进行选择，本人比较喜欢Pisces风格。不同风格的设置有些许差异,在此将不做论述，具体可以详细阅读官方文档。12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 菜单设置菜单设置涉及到的文件有 文件名称 说明 themes/next/_config.yml 菜单项目开关设置 themes/next/language/zh-CN.yml 菜单中英文对照表，可以添加 打开配置文件，修改menu设置取消常用的tags和categories的注释。也可以根据自己的喜好添加或者修改菜单内容。因为不需要修改比较个性的菜单中文名称，这里没有对zh-CN.yml文件进行修改。123456789menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 设置完成后，多出了两个菜单项标签和分类 但是点击进去后找不到相应的页面，这时就需要接下来的操作。 创建tags和categoryies页面使用命令创建页面，并修改source文件夹中对应文件夹中的index.md12$ hexo new page tags$ hexo new page categories 设置完成后，修改文章meta中的内容，添加上标签和分类项。tags和categories进行了两种不同的写法，可以使用其中的任意一种。两者不同的是多个tag是平级的，多个category是从前到后（从上到下）分级的。 功能扩展添加头像在source文件夹中添加images文件夹，将自己的头像图片拷贝到文件夹中，然后在配置文件中修改Avator设置12345678# Sidebar Avataravatar: url: /images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false 添加社交链接在配置文件中找到Social Links设置，添加个人的社交网络账号。本人主要添加了两个，然后设置成只显示图标的方式。1234567social: GitHub: https://github.com/xuemzhan || github Weibo: https://weibo.com/nimeux || weibosocial_icons: enable: true icons_only: true transition: false 添加RSS设置RSS前，需要安装依赖包hexo-generator-feed1$ npm install hexo-generator-feed --save 在站点配置文件中添加feed项目12345# RSS Settingsfeed: type: atom path: atom.xml limit: 20 添加友情链接在配置文件中找到links设置项1234567# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inlinelinks: 友情链接: http://example.com/ 添加浏览进度显示1234# Back to top in sidebar (only for Pisces | Gemini).b2t: false#Scroll percent label in b2t button.scrollpercent: true 添加Fork me on github从GitHub Ribbons选择自己喜欢的样式，然后将代码复制到themes/next/layout/_loyout.swig文件中的&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;标记下面。 粘贴后需要将GitHub的链接换成自己的。同时也可以把图片下载下来放置在source/images文件夹中。123&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;&lt;a href=&quot;https://github.com/xuemzhan&quot;&gt; &lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;/images/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt; 样式优化添加边框阴影及代码样式向文件themes/next/source/css/_custom/custom.styl 添加样式1234567891011121314151617181920212223// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 边框的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 修改文章之间的分割线修改文件themes/next/source/css/_common/components/post/post-eof.styl中的样式为123456789101112.posts-expand &#123; .post-eof &#123; display: block; #margin: $post-eof-margin-top auto $post-eof-margin-bottom; #width: 8%; #height: 1px; width: 0%; height: 0px; background: $grey-light; text-align: center; &#125;&#125; 修改文章标签样式打开文件themes/next/layout/_macro/post.swig, 将&lt;div class=&quot;post-tags&quot;&gt;中的内容样式12345&lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125; &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125;&lt;/div&gt; 修改1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 添加文章字数统计功能安装文章字数统计依赖包hexo-symbols-count-time1$ npm install hexo-symbols-count-time --save 要开启该功能，需要在hexo配置文件中添加12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 然后，修改主题配置文件中的symbols_count_time设置123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 2 wpm: 275]]></content>
      <categories>
        <category>教程系列</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装与配置]]></title>
    <url>%2F2018%2F06%2F08%2Fguider%2Fhexo%2FHexo%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Hexo系列文章是本人搭建Hexo博客系统的一些记录与总结。期间，花费了一些时间和精力去搜集资料，并动手实践，觉得应该将这些过程进行总结留档，方便自己日后查看。同时也能给其他需要的人一些提示。该系列将从安装与配置、NexT主题设置和SEO等高级特性三个方面进行阐述。 本片文章主是Hexo系列的开篇，主要围绕“Hexo+Github+私有域名”搭建免备案博客，简要阐述Hexo安装环境的准备，基本命令的使用和配置实现。 环境准备及程序安装需要的软件与环境如下： Git for WindowsNode.js for Windowshexo及相关的包 Git安装和配置Git的下载、安装和配置可以参考官方文档，也可以参考这篇文章 Node.js安装和配置Node.js目前的版本已经升级到v8.11.2, 其官网的文档介绍很详尽，英文水平可以的建议直接上，当然也可以参考这篇文章 hexo安装hexo在node.js环境中安装非常的方便，只需要一条命令行1npm i -g hexo 经过上述四个步骤，环境配置如下： 创建本地Hexo工程工程创建及文件目录说明建议创建一个本地文件夹用于存放相关的文件，我在本地D盘中创建了一个github目录，然后运行hexo init命令123mkdir githubcd githubhexo init newblog hexo程序生成的newblog工程如下: 其中主要的文件夹和文件说明如下： 名称 说明 node_modules 工程依赖包存放文件夹 scaffolds 模板存放文件夹, 默认包含有post, draft和page三个 source 文章markdown格式存放文件夹 themes 各种主题，本系列文章主讲的NexT模板就存在该文件夹中 public 上面截图中还未生成，在运行hexo g后会产生，用于存放工程生成的页面 _config.xml 工程的总的配置文件，本文所涉及的配置都在该文件中设置 生成及启动初始化工程后，个人博客的站点基本的基本框架已经搭建，且有一个默认的主题landscape在themes文件中，因此我只需要运行命令：12hexo g # 或者hexo generatehexo s # 或者hexo server 就会在本地启动一个端口为4000的服务，截图如下： 配置设置及说明上述的步骤已经将hexo工程搭建完毕，接下来就进行个性化的设置。我们使用Atom作为编辑器对工程文件进行统一的管理与操作，关于Atom请查看官网。 hexo站点全局配置在文件_config.yml中。配置的第一项肯定是站点名称、站点内容等描述。1234567title: 半吊码工subtitle: 知识应予记录, 经验应当传播description: 半路出家, 不似半路出家人keywords: "技术, 生活, 感想"author: 半吊码工language: zh-CNtimezone: 上述是本人的博客描述，其中说明的一点就是hexo支持多语言的，中文简体的配置是zh-CN，老版本为zh-Hans。 接下来一般是设置主题1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 由于本人十分喜欢NexT主题，因此本示例中将使用NexT主题，而且接下来几篇将重点介绍NexT主题的配置。 另外，为了方便书写，特别是方便在markdown中添加图标，可以将post_asset_folder设置成true， 安装hexo-asset-image依赖包。 1post_asset_folder: true 1npm install hexo-asset-image --save 这样添加一篇新文章是，系统会帮助我们生成一个同名的文件夹，用于存放附件（图片）等，方便在文中直接引用。 Github配置与链接Hexo工程准备好后，接下来就是将其发布到github并实现在线访问。 注册github并创建repository如果没有github账号，则先注册，然后创建一个符合github pages要求的repository，其实就是创建一个和用户一致的并且以.github.io结尾的工程。例如我的就是xuemzhan.githu.io。 Gitbash配置与链接首先设置Git的用户与邮箱12git config --global user.name = "xuemzhan"git config --global user.email = "xuemzhan@163.com" 然后使用ssh-keygen创建RSA公钥，如果存在则直接拷贝公钥内容。 1ssh-keygen -t rsa -C "xuemzhan@163.com" 登入github, 选择Settings-&gt;SSH and GPG keys-&gt;New SSH key将复制到公钥内容填入。 使用如下命令进行测试1ssh -T git@github.com 如果出现如下内容，则标明git配置及链接成功 hexo工程发布修改网站配置文件_config.yml中关于Deployment的内容123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/xuemzhan/xuemzhan.github.io.git branch: master 注：这里有一个坑是type类型一定是git而不是github 然后将博客站点发布到github上1234npm install hexo-deployer-git --savehexo cleanhexo ghexo d 最后通过yourname.github.io进行访问测试，本人的如下： 域名解析及测试查找github pages对应IP如果自己申请了域名，可以将自己的域名绑定到github pages上。本人的域名实在阿里云上申请的，所有路由解析需要在上面进行设定。设定前，需要查看自己github pages指向的IP地址 1ping -4 xuemzhan.github.io 域名解析进入域名解析页面填写DNS解析规则 创建域名CNAME在hexo工程的source文件夹中，创建文件CNAME,其中内容的是自己的域名。 最后，重新生成并发布 12hexo ghexo d 附录常用命令 命令名称 描述 hexo clean clean 清除缓存文件db.json和已生成的静态文件 public文件夹中 hexo g generate 生成静态文件 hexo s server 启动服务器 hexo d deploy 部署网站。部署网站前，需要预先生成静态文件 hexo new post “title” 创建一篇新的博文 hexo new page “title” 创建一个新的页面 需要的依赖包 包名称 依赖操作 hexo-deployer-git hexo d hexo-asset-image 用于图片插入]]></content>
      <categories>
        <category>教程系列</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
