<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F20%2Ftech%2Finnvo%2F%E4%B8%93%E5%88%A9%E8%AE%BE%E6%83%B3%2F</url>
    <content type="text"><![CDATA[专利构思 一种移动条件下单GPU多模型的调度方法 一种移动条件下双GPU多模型的调度方法 一种移动条件下多GPU多模型的调度方法 云平台上一种人工智能服务数据收集方法 云平台上一种人工智能服务数据收集与再训练结构 一种人工智能服务数据快速储存方法]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F12%2Ftech%2Fcrypt%2FGemalto%E8%BD%AF%E7%A1%AC%E7%8B%97%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Gemalto Sentinel LDK 设置安装将Installation Disk中的文件安装到Windows系统中，一般也指EMS的安装 硬Key制作与使用 在EMS中添加Feature和Product(可以参照官方文档)，在配饰feature时注意feature的ID，该ID在加密文件时需要。 新建Entitlements，选择Product，插入黑色的Key进行烧制 使用http://localhost:1947查看生成的key 将安装Disk中Linux拷贝到需要运行Docker的宿主服务器中 安装Linux/Redistribute/Runtime/aksusbd_7.80-1_amd64.deb，并开放1947端口 1dpkg -i aksusbd_7.80-1_amd64.deb 使用Linux/VectorTools/Envelope/linuxenv 对so文件进行加密， DEMOMA.hvc是工具授权文件 1./linuxenv -d -v:DEMOMA.hvc -f:5001 util.so util_p.soz 在Docker镜像中安装aksusbd驱动，并使用privileged模式启动镜像。 软Key制作与使用]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F25%2Ftech%2Fjenkins%2F%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[构建用户组和用户 12#sudo groupadd build#sudo useradd -d /jenkins -p l1admin --groups build jenkins]]></content>
  </entry>
  <entry>
    <title><![CDATA[CodeReview使用向导]]></title>
    <url>%2F2018%2F08%2F02%2Fguider%2Fdevops%2FCodeReview%E4%BD%BF%E7%94%A8%E5%90%91%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[代码审核（Code Review）是软件研发质量保障机制中非常重要的一环，能够有效提高代码质量。目前团队使用的工具是基于gerrit搭建，结合git-review工具提交代码审查申请。 环境软件要求 git python 账号创建与配置目前gerrit系统没有与公司账号系统打通，因此在使用系统需要账号的设置工作。设置工作包括账号申请和账号设置两个步骤。 账号申请将ITCode发送给Gerrit系统管理员`zhangxm@xxxx.com，邮件题目标明&quot;Gerrit`账号申请”。通过申请后管理员会将密码通过邮箱发送给申请者。 设置账号账号设置需要如下五个步骤： 1.登入Gerrit系统 http://10.100.208.502.进入系统后点击右上角用户名，选择下拉框的Settings选项3.使用ssh-keygen命令生成个人的SSH Key1234# 在windows中使用右键`Git Bash Here`打开$ ssh-keygen -t rsa -C &lt;itcode&gt;@xxxx.com -f ~/.ssh/id_gerrit# 复制公共Key$ cat ~/.ssh/id_gerrit.pub 4.在左边栏Settings菜单中选择SSH Public Keys，然后将3步复制的Key添加的系统中。5.验证系统是否连接成功12345678910111213$ ssh -p 29418 -i ~/.ssh/id_gerrit 10.100.208.50 -l &lt;your itcode&gt;# 如果连接成功则会出现如下提示**** Welcome to Gerrit Code Review **** Hi &lt;your itcode&gt;, you have successfully connected over SSH. Unfortunately, interactive shells are disabled. To clone a hosted Git repository, use: git clone ssh://zhangxm34@10.100.208.50:29418/REPOSITORY_NAME.gitConnection to 10.100.208.50 closed. 工具设置Gerrit系统支持原生的git命令，但命令比较复杂，因此需要git-review辅助开发人员进行相关操作。如果不想安装可以自行查看Gerrit的相关文档。 git-review下载安装git-review下载安装比较方便，在python环境下直接使用pip下载安装。1$ pip install git-review 参数设置git参数12$ git config --global user.name &lt;your itcode&gt;$ git config --global user.email &lt;your itcode&gt;@xxxx.com ssh配置文件在home目录（windows：c/Users/&lt; your computer account name&gt;/）下.ssh文件夹中添加config文件，配置内容如下12345678910111213# gitlab for xxxxHost gitlab.xxxx.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaUser zhangxm34# gitlab for ci test# 克隆源代码Host 10.100.208.50Port 2222PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaUser zhangxm34 使用示例下载源代码12345678$ git clone git@10.100.208.50:zhangxm/CapLogger.gitCloning into 'CapLogger'...remote: Counting objects: 25, done.remote: Compressing objects: 100% (18/18), done.remote: Total 25 (delta 0), reused 0 (delta 0)Receiving objects: 100% (25/25), 7.07 KiB | 1.18 MiB/s, done.$ cd CapLogger 初始化git-review123$ git review -sCreating a git remote called 'gerrit' that maps to: ssh://zhangxm34@10.100.208.50:29418/CapLogger 修改代码并提交1234$ echo "hello world from zhangxm34" &gt;&gt; README.md$ git add .$ git commit -m 'zhangxm34 review test'$ git review 经过上述步骤，提交者会收到一份邮件，表明Review请求已经提交成功，可以登入Gerrit系统进行查看。]]></content>
      <categories>
        <category>教程系列</category>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>gerrit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令大全]]></title>
    <url>%2F2018%2F08%2F01%2Ftips%2FGit%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Git是开发过程中经常用到的工具，本文主要将日常中常用的git命令进行梳理和记录。 Git主流程图在开始罗列命令前，先给一张经常看到的图，这图正式所谓的“大道至简”，虽然简单，但也不简单。 Git命令归类查看、添加、提交、删除、找回，重置修改文件1234567891011121314151617181920212223git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt;git ci .git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am "some comments"git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diff123456git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录1234git log git log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息 Git 本地分支管理查看、切换、创建和删除分支1234567891011121314git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase12345git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于：git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)123git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理1234git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 Git远程分支管理12345678910111213141516git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 Git远程仓库管理12345git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库1234567git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支 Others123#也可以命令设置跟踪远程库和本地库git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop]]></content>
      <categories>
        <category>小窍门</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell使用小记]]></title>
    <url>%2F2018%2F07%2F31%2Ftips%2FShell%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[结合expect工具实现命令自动输入123456789101112131415161718192021222324NUM=$#if [ $NUM != 3 ]; then echo "Add gerrit user and password:" echo " Usage: add_gerrit_user UserName Password Email" exit 1;fiNAME=$1if [ $NUM -eq 2 ];then PWD=$2else PWD=l1adminfiexpect &lt;&lt; __EOFspawn htpasswd /etc/nginx/conf.d/gerrit.passwd $NAMEexpect &#123; "New password" &#123; send "$PWD\r"; exp_continue &#125; "Re-type new password" &#123; send "$PWD\r"; exp_continue &#125;&#125;__EOF]]></content>
      <categories>
        <category>小窍门</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发客户代码环境工具与配置]]></title>
    <url>%2F2018%2F07%2F30%2Fguider%2Fdevops%2F%E5%BC%80%E5%8F%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[导言：针对不同的语言，每一位开发人员都有各自熟悉的开发工具，本教程主要描述怎样搭建CAP的代码开发环境，包括工具选择和开发环境设置两个部分，并支持Windows和Linux两大操作系统。其中涉及到的Java与Pthon语言开发工具和开发环境不做描述。 工具选择 git (git for windows) git-review]]></content>
      <categories>
        <category>教程系列</category>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git-review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql[MariaDB]使用小记]]></title>
    <url>%2F2018%2F07%2F23%2Ftips%2FMysql-MariaDB-%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[启用远程Root访问权限12MariaDB [(none)]&gt; grant all privileges on *.* to 'root'@'%' identified by \'l1admin' with grant option;]]></content>
      <categories>
        <category>小窍门</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>MariaDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven使用小记]]></title>
    <url>%2F2018%2F07%2F20%2Ftips%2FMaven%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[如果到现在你都不会Maven，那请别说自己时Java开发工程师 Maven国内仓库在.m2文件夹中添加settings.xml文件123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;mirrors&gt; &lt;!-- 阿里云仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库1 --&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt;]]></content>
      <categories>
        <category>小窍门</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Docker镜像的Gerrit安装与配置]]></title>
    <url>%2F2018%2F07%2F20%2Fguider%2Fdevops%2F%E5%9F%BA%E4%BA%8EDocker%E9%95%9C%E5%83%8F%E7%9A%84Gerrit%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Gerrit是用于代码Review的开源工具，具体介绍和描述详见其官网。本博文主要用于记录基于Docker镜像的服务搭建过程及整个过程中遇到的一些大大小小的坑。 搭建Gerrit环境下载Gerrit官方镜像并按照文档说明进行配置运行服务12345678910$ docker run -dit --name gerrit -p 8002:8080 -p 29418:29418 \-v ~/gerrit:/var/gerrit/review_site \-e WEBURL=http://10.144.44.156:8002 -e AUTH_TYPE=HTTP \-e SMTP_SERVER=smtp.163.com \-e SMTP_SERVER_PORT=465 \-e SMTP_ENCRYPTION=ssl \-e SMTP_USER=xuemzhan@163.com \-e SMTP_PASS=zhangxuemin0813 \-e SMTP_FROM=xuemzhan@163.com \openfrontier/gerrit 该步骤比较简单，主要在写配置信息时需要根据自身的需求进行调整。但也可以在启动后对配置文件进行直接修改进行配置，其步骤如下： 启动镜像服务 12$ docker run -dit --name gerrit -p 29418:29418 \-v ~/gerrit:/var/gerrit/review_site openfrontier/gerrit 打开Gerrit配置文件进行编辑 1$ vim ~/gerrit/etc/gerrit.config 其具体的配置信息如下：123456789101112131415161718192021222324252627282930313233343536373839[gerrit] basePath = git serverId = fc2c13d5-7037-48da-bb2c-dfa412807898 canonicalWebUrl = http://10.144.44.156:8002[database] type = h2 database = /var/gerrit/review_site/db/ReviewDB[index] type = LUCENE[auth] type = HTTP gitBasicAuthPolicy = HTTP[receive] enableSignedPush = false[sendemail] smtpServer = smtp.163.com enable = true smtpServerPort = 465 smtpUser = xxx@163.com smtpPass = ********** smtpEncryption = ssl sslVerify = false from = xxx@163.com[container] user = gerrit2 javaHome = /usr/lib/jvm/java-1.8-openjdk/jre[sshd] listenAddress = *:29418[httpd] listenUrl = http://*:8080/[cache] directory = cache[plugins] allowRemoteAdmin = true[plugin &quot;events-log&quot;] storeUrl = jdbc:h2:/var/gerrit/review_site/db/ChangeEvents[gitweb] cgi = /usr/share/gitweb/gitweb.cgi type = gitweb 需要注意是canonicalWebUrl必须要填Gerrit对外的服务入口地址 重启服务1$ docker restart gerrit 搭建Nginx代理服务当Gerrit的配置文件中auth选择HTTP选项时，需要使用Apache Httpd或者Nginx代理服务进行访问。 准备文件系统环境 12$ mkdir -p ~/nginx/conf$ cd ~/nginx/conf 创建Nginx配置文件default.conf 12345678910111213141516171819$ vim ~/nginx/conf/default.confserver &#123; listen 80; server_name localhost; location / &#123; auth_basic "Welcome to Gerrit Code Review"; auth_basic_user_file /etc/nginx/conf.d/gerrit.passwd; proxy_pass http://gerrit:8080; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; &#125; location /login/ &#123; proxy_pass http://gerrit:8080; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; &#125;&#125; 创建HTTPD用户名和密码文件gerrit.passwd 123$ sudo yum install httpd$ cd ~/nginx/conf$ htpasswd -c gerrit.passwd gerrit #添加用户去掉`-c`参加即可 运行nginx镜像 1234$ docker run -dit --name nginx -p 8002:80 \-v /home/xuemzhan/nginx/conf/default.conf:/etc/nginx/conf.d/default.conf \-v /home/xuemzhan/nginx/conf/gerrit.passwd:/etc/nginx/conf.d/gerrit.passwd \--link gerrit:gerrit nginx 搭建基于SSL的Nginx服务 将Gerrit的配置文件中的canonicalWebUrl修改成https://10.122.44.156 在~/nginx/conf路径下添加认证文件 123$ cd ~/nginx/conf$ openssl req -x509 -days 3650 -subj "/CN=10.122.44.156/" \-nodes -newkey rsa:4096 -sha256 -keyout gerrit.key -out gerrit.crt 修改nginx的配置文件default.conf 123456789101112131415161718192021server &#123; listen 443; server_name localhost; ssl on; ssl_certificate conf.d/gerrit.crt; ssl_certificate_key conf.d/gerrit.key; location / &#123; auth_basic "Welcome to Gerrit Code Review"; auth_basic_user_file /etc/nginx/conf.d/gerrit.passwd; proxy_pass http://gerrit:8080; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; &#125; location /login/ &#123; proxy_pass http://gerrit:8080; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; &#125;&#125; 重新启动nginx镜像服务 123456$ docker run -dit --name nginx -p 8002:80 \-v /home/xuemzhan/nginx/conf/default.conf:/etc/nginx/conf.d/default.conf \-v /home/xuemzhan/nginx/conf/gerrit.passwd:/etc/nginx/conf.d/gerrit.passwd \-v /home/xuemzhan/nginx/conf/gerrit.key:/etc/nginx/conf.d/gerrit.key \-v /home/xuemzhan/nginx/conf/gerrit.crt:/etc/nginx/conf.d/gerrit.crt \--link gerrit:gerrit nginx 访问https://10.122.44.156]]></content>
      <categories>
        <category>教程系列</category>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>gerrit</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令小记]]></title>
    <url>%2F2018%2F07%2F18%2Ftips%2FGit%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录日常Git使用过程中的点滴 github和gitlab仓库一起使用 分别创建github和gitlab本地SSH RSA Key 12$ ssh-keygen -t rsa -C "注册的gitlab邮箱" -f ~/.ssh/gitlab_rsa$ ssh-keygen -t rsa -C "注册的gitlab邮箱" -f ~/.ssh/github_rsa 将生成的gitlab_rsa.pub和github_rsa.pub拷贝到系统中Profile-&gt;Settings-&gt;SSH Keys 12$ cat gitlab_rsa.pub | clip$ cat github_rsa.pub | clip 在${USER}/.ssh/目录下添加config文件，并进行配置 123456789101112131415161718192021# 配置文件参数# Host : Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件# HostName : 要登录主机的主机名# Port 端口号，默认为22# User : 登录名# IdentityFile : 指明上面User对应的identityFile路径# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_rsaUser xuemzhan# gitlabHost gitlab.xxxxx.comHostName gitlab.xxxxx.comPort 50022PreferredAuthentications publickeyIdentityFile ~/.ssh/gitlab_rsaUser xuemzhan 在不同的项目中设置用户和邮箱 123456789101112$ git init$ git config --local user.name 'personal'$ git config --local user.email 'personal@xxxx.com'```s5. 测试```shell# 测试github$ ssh -T git@github.com# 测试gitlab$ ssh -T git@gitlab.com Bad owner or permissions on /home//.ssh/config 1$chmod 600 config git clone --bare与git clone --mirror区别两个命令都表示克隆的版本不包含工作区，直接是版本的内容，这样克隆的版本成为裸版本库。一般约定裸版本库以.git为后缀。两者的区分是mirror克隆的对上游版本进行了注册，这样可以使用git fetch与上流的版本进行同步，而bare则没有。 在提交前撤销git commit123456# 查看需要撤销的`id`$ git log#完成撤销,同时将代码恢复到前一commit_id 对应的版本$ git reset --hard &lt;id&gt;#完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改$ git reset &lt;id&gt;]]></content>
      <categories>
        <category>小窍门</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins+Gerrit+Gitlab构建随记]]></title>
    <url>%2F2018%2F07%2F18%2Fguider%2Fdevops%2FJenkins-Gerrit-Gitlab%E6%9E%84%E5%BB%BA%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[配置端口设定名称|端口号-|-gitlab | 443, 8001, 50022jenkins | 8080,50000 Gitlab-ce安装 创建gitlab文件夹用于保存数据与配置 使用Docker启动镜像 12$ docker run -d --name gitlab --restart always -p 443:443 -p 8001:80 -p 50022:22 \ -v ~/gitlab/config:/etc/gitlab -v ~/gitlab/logs:/var/log/gitlab -v ~/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce 登入容器修改配置123$ docker exec -it gitlab /bin/bash$ vim /etc/gitlab/gitlab.rb$ docker restart gitlab Jenkins安装 下载Jenkins的(Docker镜像文件)[https://hub.docker.com/_/jenkins/] 设置数据卷并启动镜像12345678$ docker run -dit --restart always --name jenkins -p 8080:8080 -p 50000:50000 \-v /home/$&#123;USER&#125;/jenkins:/var/jenkins_home jenkins## `Gerrit`安装与配置 ##```shell$ docker run -dit -p 8002:8080 -p 29418:29418 -v ~/gerrit:/var/gerrit/review_site -e WEBURL=http://10.144.44.156:8002 -e AUTH_TYPE=HTTP -e SMTP_SERVER=smtp.163.com -e SMTP_SERVER_PORT=465 -e SMTP_ENCRYPTION=ssl -e SMTP_USER=xuemzhan@163.com -e SMTP_PASS=zhangxuemin0813 -e SMTP_FROM=xuemzhan@163.com --name gerrit openfrontier/gerrit 安装Nginx反向代理1$ docker run -dit --name nginx -p 443:443 -v /home/xuemzhan/nginx/conf/default.conf:/etc/nginx/conf.d/default.conf -v /home/xuemzhan/nginx/conf/gerrit.passwd:/etc/nginx/conf.d/gerrit.passwd --link gerrit:gerrit xuemzhan/nginx_ssl_gerrit]]></content>
      <categories>
        <category>教程系列</category>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>Gitlab</tag>
        <tag>Gerrit</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS命令小记]]></title>
    <url>%2F2018%2F07%2F17%2Ftips%2FCentOS%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[涉及到的CentOS命令 普通用户sudo免密码配置 修改对应文件权限 12$ sudo chmod u+w /etc/sudoers$ sudo vi /etc/sudoers 查找 root ALL=(ALL) ALL在其下一行， 添加或者取消注释 infomgr ALL=(ALL) NOPASSWD: ALL 检验12$ sudo chmod u-w /etc/sudoers$ sudo whoami 非root用户Docker免sudo1234$ sudo groupadd docker$ sudo gpasswd -a $&#123;USER&#125; docker$ sudo chmod u+rw /var/run/docker.socket$ sudo service docker restart 添加删除用户1$ sudo userdel -rf &lt;USER&gt; 安装Apache2 Apache默认将网站的根目录指向/var/www/html默认的主配置文件/etc/httpd/conf/httpd.conf配置存储在的/etc/httpd/conf.d/目录1234$ sudo yum install httpd$ sudo systemctl enable httpd.service$ sudo systemctl is-enabled httpd.service$ systemctl start |stop | restart httpd.service Centos 7使用firewalld代替了原来的iptables。123$ firewall-cmd --zone=public --add-port=80/tcp --permanent$ firewall-cmd --reload$ firewall-cmd --state Docker镜像加速12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;&#123; &quot;registry-mirrors&quot;: [&quot;https://1mwzv8d2.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker]]></content>
      <categories>
        <category>小窍门</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷摘记]]></title>
    <url>%2F2018%2F07%2F17%2Ftips%2F%E6%95%8F%E6%8D%B7%E6%91%98%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基础与概念 scrum team: 整个组织架构中可进行独立开发的最小团队, 一般人数控制在5~10人左右 sprint：项目开发过程中最小迭代周期，根据同的项目周期不同；现有产品维护1~5天，二次开发5~10，新项目5~30，业务复杂或开发所用语言较多或开发复杂度较高10~45 point：不可拆分的最小功能点数，1point等于多少小时，可以由项目主管按照项目的实际情况指定。 Product Backlog：由PO负责管理，将所有epic按优先顺序排列的一个产品需求列表。 Sprint Backlog：通过Sprint Planning Meeting，由PM、PO、SM从product backlog中挑选出一个或多个Story作为本次迭代完成的目标 epic：一个包含完成功能的需求描述，可以被拆分为1个或多个stroy，一般有PO划分 story：一个不可拆分子功能描述，可以被拆分为1个过多个task，一般由PO将epic拆分为story，在Sprint Planning Pre-Plan Meeting中PO、SM确定story是否合理并做相应的调整。 task：最小可用于开发的任务，在sprint开始时由ST将story拆分为task，并在当前sprint中完成 product Master(PM)：管理整个项目的整体进度，也可叫做scrum master of scrums. product owner(PO)：管理整个项目或多个scrum team的需求，并将需求转换为epic或story，指定软件交付日期，指定交付标准，有权力接受或拒绝开发团队的工作成果 scrum master(SM)：整体控制一个scrum能过承接的point数；监控每个sprint的整体进度；协调与其他scrum team之间的沟通 technique leader(TL)：整个项目或多个scrum team或一个scrum team的技术专家，主要负责在开发过程中给出技术解决方案或建议 scrum team member(ST)：scrum项目成员，主要负责开发，以及将指派给自己的story拆分为task Sprint Planning Pre-Plan Meeting：PO、SM确定挑选story为后期sprint做准备，一般提前2个sprint Sprint Planning Meeting：在sprint之前PO将下个sprint需要完成的story交付给SM，SM需要根据目前ST的能力确认point数，此时应该确认或拒绝下一个sprint所有需求。 Sprint start meeting：在sprint的第一天将当前sprint的story指派给相关ST，除非TL提出异议并且征得PO或PM同意，否则所有stroy必须在当前sprint完成。 Srpint Review Meeting：也叫Srpint Demo Meeting，将这个sprint的成果演示给PO，由PO确认演示内容是否符合交付标准，并提出改善意见。 Sprint Retrospective Meeting：回顾会议，SM、ST、TL，PO参与对于上一个sprint成果总结，优点继续保持，缺点或缺陷根据实际情况由PO决定是否建立story放入Product Backlog中，在以后或下一个sprint中完善。 Daily Scrum Meeting：也叫stand up meeting，每天占用5~15分钟汇报、分享、提出问题。特别注意此会议不解决任何问题。 Scrum of Scurms meeting：大型项目需要，多个scrum team协同开发时，多个Team SM参与讨论会议；对上一个sprint总结汇报，并提出相关意见，如果涉及到代码改善意见，需要请PO确认是否建立story；下一个sprint资源确认，是否需要其他Team协助，是否有人力资源调整等问题]]></content>
      <categories>
        <category>同心同德</category>
      </categories>
      <tags>
        <tag>scrum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK平台搭建]]></title>
    <url>%2F2018%2F07%2F16%2Ftech%2Flog%2FELK%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"></content>
      <categories>
        <category>温故知新</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter使用杂记]]></title>
    <url>%2F2018%2F07%2F13%2Ftips%2FJupyter%E4%BD%BF%E7%94%A8%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Jupyter是学习、记录和传授的超级工具，其可见可得，代码和文档一起的风格，我都要爱死了。 Jupyter Notebook设置远程访问修改jupyter_notebook_config.py文件中的c.NotebookApp.ip属性为’*’1# vim ~/.jupyter/jupyter_notebook_config.py]]></content>
      <categories>
        <category>小窍门</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda命令小记]]></title>
    <url>%2F2018%2F07%2F13%2Ftips%2FAnaconda%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Anconda 学习与使用机器学习和深度学习必不可少的工具，本博文将不断记录工作中碰到的需要记忆的命令和一些使用上的小窍门，主要是为了方便今后查询及记忆 添加国内镜像123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/freeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/mainconda config --set show_channel_urls yes 恢复默认的源1conda config --remove-key channels]]></content>
      <categories>
        <category>小窍门</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes概述与架构]]></title>
    <url>%2F2018%2F06%2F24%2Ftech%2Fk8s%2FKubernetes%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Kubernetes是一个用于管理容器化应用和服务的轻便和可扩展的开源平台。通过Kubernetes能够进行应用的自动化部署和扩缩容。在Kubernetes中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。 主要特性1.自动化装箱：对资源的要求和约束自动部署容器，同时为了提高利用率和节省更多资源，将关键和最佳工作量结合在一起。 2.自愈能力：当容器失败时，对容器进行重启；当部署的Node节点有问题时，对容器进行重新部署和重新调度；当容器未通过监控检查时，会关闭容器；只有容器正常运行，才会对外提供服务。 3.水平扩展：通过简单命令、用户界面或者基于CPU的适用情况对应用容器进行扩展。 4.服务发现和负载均衡：基于Kubernetes进行服务发现和负载均衡，开发者不需要适用额外的服务发现机制。 5.自动发布和回滚：Kubernetes能够程序化的发布应用和相关配置，如果发布有问题，能够会贵发生的变更。 6.保密和配置管理： 在不需要重新构建镜像的情况下，可以部署和更新保密和应用配置。 7.存储编排：自动挂接本地、公有云、网络存储系统。 架构图Kubernetes属于主从分布架构，主要由Master Node、Worker Node、Kubectl和其他附加项构成。 Master NodeMaster Node是控制节点，对整个集群进行调度管理。它由API Server、Scheduler、Cluster State Store和Controller-Manager组成. API ServerAPI Server是所有REST命令的入口，用于REST的操作，确保它们生效，执行相关业务逻辑，以及更新etcd。另外，API Server作为集群网关。默认情况下，客户端通过API Server对集群进行访问。 SchedulerScheduler组件为容器自动选择运行的主机。依据请求资源的可用性，服务请求的质量等约束条件，监控未绑定的pod, 并将其绑定至特定的node节点。 Scheduler可以依据的调度策略主要有预选策略和优选策略。 Cluster State StoreKubernetes默认使用etcd作为集群整体存储。etcd是一个简单的、分布式的、一致的key-value存储，主要被用来共享配置和服务发现。etcd提供了一系列CRUD操作API，以及作为注册的接口用于监控置顶的Node。集群所有的状态都存储在etcd实例中，并具有监控能力，当etcd中的信息发生变化时，就能够快速的通知集群相关的组件。 Controller-Manager用于执行大部分的集群层次功能，它即执行例如命名空间创建、生命周期管理、事件垃圾收集、已终止垃圾收集、联级删除垃圾收集、node垃圾收集等生命周期功能，也执行例如pod的弹性扩容等API业务逻辑。控制管理提供自愈能力、扩容、应用生命周期管理、服务发现、路由、服务绑定等。 Worker NodeWorker Node作为真正的工作节点，运行业务应用的容器；其包含kubelet、kube proxy和Container Runtime kubeletKubelet是Pod和Node API的主要实现者，并负责驱动容器执行层，负责管理Pod、容器、镜像和数据卷，实现集群对节点的管理，并将容器的运行状态汇报给Kubernetes API Server。在Kubernetes中，Pod作为基本的执行单元，它可以拥有多个容器和存储数据卷，能够方便在每一个容器中打包一个单一的应用，从而解耦了应用构建时和部署时的所关心的事项，已经能够方便在物理机/虚拟机之间进行迁移。API准入控制可以拒绝Pod，或者为Pod添加外的调度约束，但是Kubelet才是Pod是否能够运行在特定Node上的最终裁决者。 Container Runtime每一个Node都会运行一个Container Runtime, 其负责下载镜像和运行容器。 Kubernetes本身不提供容器运行环境，但提供了接口，可以插入所选择的容器运行时环境。Kubelet使用Unix socket之上的gRPC框架与容器运行时进行通信， Kubelet作为客户端，CRI shim作为服务器。 protocal buffers API提供ImageService和RuntimeService两个gRPC服务。ImageService提供拉去、查看和移除镜像的RPC。RuntimeService则提供管理Pods和容器生命周期管理的RPC，以及与容器进行交互(exec/attach/port-forward)。 Kube proxy基于一种公共访问策略（例如：负载均衡），服务提供了一种访问一群pod的途径。此方式通过创建一个虚拟的IP来实现，客户端能够访问此IP，并能够将服务透明的代理至Pod。每一个Node都会运行一个kube-proxy，kube proxy通过iptables规则引导访问至服务IP，并将重定向至正确的后端应用，通过这种方式kube-proxy提供了一个高可用的负载均衡解决方案。服务发现主要通过DNS实现。 在Kubernetes中，kube proxy负责为Pod创建代理服务；引到访问至服务；并实现服务到Pod的路由和转发，以及通过应用的负载均衡。 Kubectlkubectl是Kubernetes集群的命令行接口。运行kubectl命令的语法如下所示： 1$ kubectl [command] [TYPE] [NAME] [flags]]]></content>
      <categories>
        <category>温故知新</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强化学习要点]]></title>
    <url>%2F2018%2F06%2F23%2Ftech%2Fai%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[广袤的塞伦盖蒂大草原上，一只角马的幼崽刚刚降生。它挣扎着，努力的站起来，一开始摇摇晃晃，不断的跌倒又站起，然后慢慢的站稳了，并开始向前走，再接着开始奔跑，来到角马母亲身旁，然后享受甘甜的乳汁。 定义强化学习是机器学习的一个重要分支，主要是用于解决decision making问题，可以自主进行（连续）决策。它主要包含Agent, Environment, Action, Reward四个元素，其目标是获取最大的Reward。 与（非）监督学习的区别我们通常说机器学习包含监督学习和非监督学习，但在定义中强化学习也是机器学习的一个重要分支，那么它与传统的监督学习与非监督学习的区别是什么？ 与监督学习的对比1.监督学习训练集结果有标签；强化学习没有，需要尝试一些行为得出一个结果然后根据结果的反馈调整之前的行为。 2.监督学习算法能够从结果中马上得到反馈；强化学习的结果反馈有延时，有时要经过好几步后才能知晓前面的行为是否有问题。 3.监督学习的输入是独立分布的；强化学习输入总在变化，当算法做出一个行为时，它能够影响下一个输入，输入是相关联的。 4.监督学习一般只会尝试过去经验中最有效的行为（exploitation）；强化学习可以在尝试不同事务（exploration）和尝试过去经验中最有效行为（exploitation）两者中找到平衡点，从而得到最大回报。 5.监督学习会学习得到一个输入与输出的映射关系；强化学习给出的是reward function，用来判断行为的好坏。 与非监督学习的对比 在用户推荐系统中，非监督学习会找出与用户先前行为类似的行为；强化学习则通过向用户推荐一些，等待用户反馈后修正对用户的推荐。 非监督学习得到的结果是输入与输出的模式；强化学习得到是映射。 算法分类强化学习的算法可以以reward,action,policy几个主要元素角度进行区分. Reward based是算法关注找到最优奖励总和； Action based是算法关注找到每一步的最优行动； Policy based是算法关注找到最优的策略； 在上述的基础上，还有进行更加细分区分： 算法 Model-free Model-based Policy-based Reward-based MC-update TD-update On-policy Off-policy QLearning True True True True True Sarsa True True True True True Policy Gradients True True True True Actor-critic True True Policy Gradients V2 True MC learning True Sarsa lambda True Deep Q Network True Model-free: 不尝试去理解环境，环境给什么就是什么，一步一步等待真是世界的反馈，再根据反馈采取下一步的行动；Model-based: 先理解真实世界是怎样的，并建立一个模型来模拟现实世界的反馈，然后通过想想来预判接下来将要发生的所有情况，选择这些想象中最好的，并依据这种情况采取下一步策略，相对于Model-free算法多处一个虚拟环境，更有想象力；Policy-based: 通过感官分析所处的环境，直接输出下一步要采取的各种动作的概率，然后根据概率采取行动；Reward-based: 输出的是所有动作的价值，根据最高价值来选动作，这类方法不能选区联系的动作；MC-update: Monte-carlo update是指游戏开始后，要等待游戏结束后，然后再总结这一回合中的所有转折点，再更新新的行为准则；TD-update: Temporal-difference update是指在游戏进行中每一步都在更新，不用等待游戏结束，这样就能边玩边学;On-policy： 必须本人在场，且一定是本人边玩边学习；Off-policy: 可以选择自己玩也可以看着别人玩，通过看别人玩来学习别人的行为准则； 引用1.一文了解强化学习]]></content>
      <categories>
        <category>温故知新</category>
        <category>AI</category>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>强化网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的分库与分表]]></title>
    <url>%2F2018%2F06%2F13%2Ftech%2Farch%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%86%E5%BA%93%E4%B8%8E%E5%88%86%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[在系统设计与架构时，绝大多数是绕不开数据库的。数据库的选型、部署方案、数据结构的切分、优化等等都是一系列需要思考的。文本针对数据库优化中的分库分表做一些阐述。 写在前面什么是最好的数据库分库分表方案？ 不需要分库分表的方案是最好的。但随着业务的发展，系统数据量和访问量的增加，有时候要进入到不得不分库分表的阶段。总结起来，分库分表的原因可以归结为： 数据的读取量急剧增加，以至于内存不能满足其需求，说白了就是内存容量不够； 数据的读取变化频幅很快，以至于查询的数据不是来自于内存还是来自硬盘； 数据的写操作超过了磁盘负载，以至于数据副本的同步更新远落后与写入操作； 具体到数据库层面，表现为： 数据库读写请求量太大； 单库数据过大； 单表数据过大； 因此，所有的分库分表方案都是基于解决上述三个问题。 面临的问题俗话说“有得必有失”，针对数据库的分库分表操作也一样。进行分库分表后可能付出的代价可能有以下几种： 原先的SQL语句不再是申明式的 数据库通过SQL语句获知用户的意图，然后适用优化器进行优化，并将优化后的SQL转换成获取程序。分库分表后，这种优势可能被打破。 可能会导致大量的网络延时 在分布式环境下，查询语句必须要通过KV映射，访问多个网络节点，或者将WHERE条件放在他们将被执行的节点上, 但是即使在最好的情况下，涉及到多个网络访问都会更加复杂。 将会失去一些SQL的强大功能 例如外键约束等 异步查询的数据不能顺序返回 当相同类型的数据存放在多个节点上（例如用户数据存放在A,B,C节点上），水平查询需要访问所有节点，数据访问时间直接因以节点数线性增长。除非多个节点是以并行方式访问，然后再以MapReduce的方式聚合。前提是需要提供异步通信的API，但这并不存在于MySQL提供的功能中, 可选的方案是在子进程中增加很多的forking和连接。 切分方法切分方法多种多样，本文将从架构层级切分和物理层级切分进行简要描述。 架构层级切分 切分方法 优点 缺点 业务功能切分 相关表都在本地，可以享受声明式的SQL语句好处， 网络延时少 可能出现单个表单数据过大的情况 业务应用层切分 可选的方案多，灵活 处理细节多，技术细节复杂。 物理切分 方法 垂直切分 水平切分 分表 大表切成小表， 拆分字段， 建扩展表 对数据量巨大的单表按照某种规则(RANGE, HASH取模等)，切分成多张表 分库 针对不同业务进行拆分 将单张表切分到多个服务器中]]></content>
      <categories>
        <category>温故知新</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习通用优化方法]]></title>
    <url>%2F2018%2F06%2F12%2Ftech%2Fai%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%80%9A%E7%94%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[深度学习的最终目标是找到最优或者近似最优的模型。当有一个模型被训练出来后，怎么去改进？是否有一个通用的方法？ 土豪法你认识或者自己就是研究领域的专家，拥有强大GPU计算集群，几乎没有限制的训练数据，先进模型的理论、架构与设计。最后有足够的时间和耐心，或者有助手帮助调参，迭代模型。 通用法通用法一般通过迁移开源的先进的模型、总结一些常用超参的调优手法进行改善模型的拟合时间和准确性。具体可以分为以下几个步骤： 模型迁移前的准备：了解最新理论成果与理想的或者目前实践上最优的模型，研究其预训练体系结构。了解迁移学习的好处，思考要解决问题的领域与现有模型的共性问题。 模型的裁剪模型的前几层，主要是提取通用的和可以解释的特征。在迁移时，不需要修改和调整。输出层则需要进行修改，主要是使用适合应用领域的激活函数和输出维度替换模型的默认输出。 训练优化1.使用较小的学习率，这是因为预训练的权重通常优于随机初始化的权重，因此修改要更为精细。2.使用Dropout层。和传统的回归模型的Ridge和LASSO正则化一样，Dropout不会适用于所有的模型。他的适用取决于具体问题，需要进行测。3.通过限制有些层的权重的最大范数（绝对值）来提高模型的泛化能力。]]></content>
      <categories>
        <category>温故知新</category>
        <category>AI</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[占卜:小米招股前景]]></title>
    <url>%2F2018%2F06%2F11%2Fdivine%2F%E5%B0%8F%E7%B1%B3%E6%8B%9B%E8%82%A1%E5%89%8D%E6%99%AF%2F</url>
    <content type="text"><![CDATA[“巨树散枝开花飘全球，根扎市场吸金流，到底是花香为大众，还是花是画金是金？” 上市圈钱都不是问题，问题是圈钱的目的是做产品还是圈钱。看好其后10年的发展。]]></content>
      <categories>
        <category>占卜记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题高级设置]]></title>
    <url>%2F2018%2F06%2F11%2Fguider%2Fhexo%2FHexo%E4%B8%BB%E9%A2%98%E9%AB%98%E7%BA%A7%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[这是Hexo系列的第三篇，主要记录一些NexT主题的一些高级特性设置，比如置顶、开启搜索，进行SEO设置等。 文章置顶功能设置文字的置顶级别top数，达到对文章的置顶设置。该功能就是修改node_modules/hexo-generator-index/lib/generator.js文件，添加根据top数值大小排序代码，从而实现该功能。 1234567891011121314151617181920212223242526module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 如果需要对文章置顶，需要在文章的meta中添加top关键字，并设置相应的数值1234567---title: Hexo主题高级设置date: 2018-06-10 17:44:33tags: [Hexo, 教程]categories: [教程系列, 工具类]top: 100--- 添加文章结束标记创建模板创建一个模板文件themes/next/layout/_macro/post-end-tag.swig 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------本文结束------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 引用模板将创建的模板添加到themes/next/layout/_macro/post.swig中 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'post-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 添加配置最后在主题配置文件中添加12post-end-tag: enabled: true 创建404页面 404页面只有发布到站点并使用域名时才会显示，本地调试或者GitHub pages域名都不能显示404页面 使用命令新建404页面， 1$ hexo new page 404 然后编辑source/404/index.md中的内容，需要注意的是需要在meta中标明permalink 123456---title: 未找到该页面date: 2018-06-11 23:07:24comments: falsepermalink: /404--- 开启本地搜索下载hexo-generator-searchdb依赖包，然后enabled搜索配置 123456789local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false 开启社区分享功能将]]></content>
      <categories>
        <category>教程系列</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题NexT配置与优化]]></title>
    <url>%2F2018%2F06%2F10%2Fguider%2Fhexo%2FHexo%E4%B8%BB%E9%A2%98NexT%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[上一篇《Hexo安装与配置》主要记录Hexo博客站点的设置过程，这一篇主要从基本设置、功能扩展和样式优化三个方面讲述NexT主题的配置。本文参考了《Hexo-Next-主题优化》系列博文，在此对作者表示感谢。NexT目前的版本的已经升级到v6.3.0，本文将以此版本为例。 前期准备下载NexT主题v6.3.0解压到themes文件夹中并重命名为next，修改站点配置文件_config.yml中的主题设置。 在没有特别说明的情况下，配置文件默认是themes/next/_config.yml主题配置文件。 基本设置主题风格NexT主题支持Muse、Mist、Pisces和Gemini四种风格，可以根据个人喜好进行选择，本人比较喜欢Pisces风格。不同风格的设置有些许差异,在此将不做论述，具体可以详细阅读官方文档。12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 菜单设置菜单设置涉及到的文件有 文件名称 说明 themes/next/_config.yml 菜单项目开关设置 themes/next/language/zh-CN.yml 菜单中英文对照表，可以添加 打开配置文件，修改menu设置取消常用的tags和categories的注释。也可以根据自己的喜好添加或者修改菜单内容。因为不需要修改比较个性的菜单中文名称，这里没有对zh-CN.yml文件进行修改。123456789menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 设置完成后，多出了两个菜单项标签和分类 但是点击进去后找不到相应的页面，这时就需要接下来的操作。 创建tags和categoryies页面使用命令创建页面，并修改source文件夹中对应文件夹中的index.md12$ hexo new page tags$ hexo new page categories 设置完成后，修改文章meta中的内容，添加上标签和分类项。tags和categories进行了两种不同的写法，可以使用其中的任意一种。两者不同的是多个tag是平级的，多个category是从前到后（从上到下）分级的。 功能扩展添加头像在source文件夹中添加images文件夹，将自己的头像图片拷贝到文件夹中，然后在配置文件中修改Avator设置12345678# Sidebar Avataravatar: url: /images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false 添加社交链接在配置文件中找到Social Links设置，添加个人的社交网络账号。本人主要添加了两个，然后设置成只显示图标的方式。1234567social: GitHub: https://github.com/xuemzhan || github Weibo: https://weibo.com/nimeux || weibosocial_icons: enable: true icons_only: true transition: false 添加RSS设置RSS前，需要安装依赖包hexo-generator-feed1$ npm install hexo-generator-feed --save 在站点配置文件中添加feed项目12345# RSS Settingsfeed: type: atom path: atom.xml limit: 20 添加友情链接在配置文件中找到links设置项1234567# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inlinelinks: 友情链接: http://example.com/ 添加浏览进度显示1234# Back to top in sidebar (only for Pisces | Gemini).b2t: false#Scroll percent label in b2t button.scrollpercent: true 添加Fork me on github从GitHub Ribbons选择自己喜欢的样式，然后将代码复制到themes/next/layout/_loyout.swig文件中的&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;标记下面。 粘贴后需要将GitHub的链接换成自己的。同时也可以把图片下载下来放置在source/images文件夹中。123&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;&lt;a href=&quot;https://github.com/xuemzhan&quot;&gt; &lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;/images/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt; 样式优化添加边框阴影及代码样式向文件themes/next/source/css/_custom/custom.styl 添加样式1234567891011121314151617181920212223// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 边框的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 修改文章之间的分割线修改文件themes/next/source/css/_common/components/post/post-eof.styl中的样式为123456789101112.posts-expand &#123; .post-eof &#123; display: block; #margin: $post-eof-margin-top auto $post-eof-margin-bottom; #width: 8%; #height: 1px; width: 0%; height: 0px; background: $grey-light; text-align: center; &#125;&#125; 修改文章标签样式打开文件themes/next/layout/_macro/post.swig, 将&lt;div class=&quot;post-tags&quot;&gt;中的内容样式12345&lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125; &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125;&lt;/div&gt; 修改1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 添加文章字数统计功能安装文章字数统计依赖包hexo-symbols-count-time1$ npm install hexo-symbols-count-time --save 要开启该功能，需要在hexo配置文件中添加12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 然后，修改主题配置文件中的symbols_count_time设置123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 2 wpm: 275]]></content>
      <categories>
        <category>教程系列</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装与配置]]></title>
    <url>%2F2018%2F06%2F08%2Fguider%2Fhexo%2FHexo%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Hexo系列文章是本人搭建Hexo博客系统的一些记录与总结。期间，花费了一些时间和精力去搜集资料，并动手实践，觉得应该将这些过程进行总结留档，方便自己日后查看。同时也能给其他需要的人一些提示。该系列将从安装与配置、NexT主题设置和SEO等高级特性三个方面进行阐述。 本片文章主是Hexo系列的开篇，主要围绕“Hexo+Github+私有域名”搭建免备案博客，简要阐述Hexo安装环境的准备，基本命令的使用和配置实现。 环境准备及程序安装需要的软件与环境如下： Git for WindowsNode.js for Windowshexo及相关的包 Git安装和配置Git的下载、安装和配置可以参考官方文档，也可以参考这篇文章 Node.js安装和配置Node.js目前的版本已经升级到v8.11.2, 其官网的文档介绍很详尽，英文水平可以的建议直接上，当然也可以参考这篇文章 hexo安装hexo在node.js环境中安装非常的方便，只需要一条命令行1npm i -g hexo 经过上述四个步骤，环境配置如下： 创建本地Hexo工程工程创建及文件目录说明建议创建一个本地文件夹用于存放相关的文件，我在本地D盘中创建了一个github目录，然后运行hexo init命令123mkdir githubcd githubhexo init newblog hexo程序生成的newblog工程如下: 其中主要的文件夹和文件说明如下： 名称 说明 node_modules 工程依赖包存放文件夹 scaffolds 模板存放文件夹, 默认包含有post, draft和page三个 source 文章markdown格式存放文件夹 themes 各种主题，本系列文章主讲的NexT模板就存在该文件夹中 public 上面截图中还未生成，在运行hexo g后会产生，用于存放工程生成的页面 _config.xml 工程的总的配置文件，本文所涉及的配置都在该文件中设置 生成及启动初始化工程后，个人博客的站点基本的基本框架已经搭建，且有一个默认的主题landscape在themes文件中，因此我只需要运行命令：12hexo g # 或者hexo generatehexo s # 或者hexo server 就会在本地启动一个端口为4000的服务，截图如下： 配置设置及说明上述的步骤已经将hexo工程搭建完毕，接下来就进行个性化的设置。我们使用Atom作为编辑器对工程文件进行统一的管理与操作，关于Atom请查看官网。 hexo站点全局配置在文件_config.yml中。配置的第一项肯定是站点名称、站点内容等描述。1234567title: 半吊码工subtitle: 知识应予记录, 经验应当传播description: 半路出家, 不似半路出家人keywords: "技术, 生活, 感想"author: 半吊码工language: zh-CNtimezone: 上述是本人的博客描述，其中说明的一点就是hexo支持多语言的，中文简体的配置是zh-CN，老版本为zh-Hans。 接下来一般是设置主题1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 由于本人十分喜欢NexT主题，因此本示例中将使用NexT主题，而且接下来几篇将重点介绍NexT主题的配置。 另外，为了方便书写，特别是方便在markdown中添加图标，可以将post_asset_folder设置成true， 安装hexo-asset-image依赖包。 1post_asset_folder: true 1npm install hexo-asset-image --save 这样添加一篇新文章是，系统会帮助我们生成一个同名的文件夹，用于存放附件（图片）等，方便在文中直接引用。 Github配置与链接Hexo工程准备好后，接下来就是将其发布到github并实现在线访问。 注册github并创建repository如果没有github账号，则先注册，然后创建一个符合github pages要求的repository，其实就是创建一个和用户一致的并且以.github.io结尾的工程。例如我的就是xuemzhan.githu.io。 Gitbash配置与链接首先设置Git的用户与邮箱12git config --global user.name = "xuemzhan"git config --global user.email = "xuemzhan@163.com" 然后使用ssh-keygen创建RSA公钥，如果存在则直接拷贝公钥内容。 1ssh-keygen -t rsa -C "xuemzhan@163.com" 登入github, 选择Settings-&gt;SSH and GPG keys-&gt;New SSH key将复制到公钥内容填入。 使用如下命令进行测试1ssh -T git@github.com 如果出现如下内容，则标明git配置及链接成功 hexo工程发布修改网站配置文件_config.yml中关于Deployment的内容123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/xuemzhan/xuemzhan.github.io.git branch: master 注：这里有一个坑是type类型一定是git而不是github 然后将博客站点发布到github上1234npm install hexo-deployer-git --savehexo cleanhexo ghexo d 最后通过yourname.github.io进行访问测试，本人的如下： 域名解析及测试查找github pages对应IP如果自己申请了域名，可以将自己的域名绑定到github pages上。本人的域名实在阿里云上申请的，所有路由解析需要在上面进行设定。设定前，需要查看自己github pages指向的IP地址 1ping -4 xuemzhan.github.io 域名解析进入域名解析页面填写DNS解析规则 创建域名CNAME在hexo工程的source文件夹中，创建文件CNAME,其中内容的是自己的域名。 最后，重新生成并发布 12hexo ghexo d 附录常用命令 命令名称 描述 hexo clean clean 清除缓存文件db.json和已生成的静态文件 public文件夹中 hexo g generate 生成静态文件 hexo s server 启动服务器 hexo d deploy 部署网站。部署网站前，需要预先生成静态文件 hexo new post “title” 创建一篇新的博文 hexo new page “title” 创建一个新的页面 需要的依赖包 包名称 依赖操作 hexo-deployer-git hexo d hexo-asset-image 用于图片插入]]></content>
      <categories>
        <category>教程系列</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
